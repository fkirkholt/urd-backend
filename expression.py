import re
from datetime import date, datetime


class Expression:
    def __init__(self, platform):
        self.platform = platform

    def concat(self, items):
        # Concat expressions and treat null as ''
        if self.platform in ('mysql', 'mariadb'):
            return "concat_ws('', " + ','.join(items) + ")"
        else:
            return ' || '.join(items)

    def concat_ws(self, sep, items):
        if self.platform in ('mysql', 'mariadb'):
            return "concat_ws('" + sep + "'," + ",".join(items) + ")"
        else:
            sep = " || '" + sep + "' || "
            return sep.join(items)

    def autoincrement(self):
        if self.platform in ('mysql', 'mariadb'):
            return "AUTO_INCREMENT"
        elif (self.platform == 'oracle'):
            return "GENERATED BY DEFAULT ON NULL AS IDENTITY"
        elif (self.platform == 'postgresql'):
            return "SERIAL"
        elif (self.platform == 'sqlite'):
            return "AUTOINCREMENT"

    def to_urd_type(self, type_):
        type_ = type_.lower()

        if re.search("json", type_):
            return "json"
        elif re.search("char|text|clob|xml|sysname|uniqueidentifier", type_):
            return "str"
        elif re.search("bool|bit|tinyint", type_):
            return "bool"
        elif re.search("int|number", type_):
            return "int"
        elif re.search("double|decimal|numeric", type_):
            return "Decimal"
        elif re.search("float|real", type_):
            return "float"
        elif re.search("date|time", type_):
            return "date"
        elif re.search("blob|image|binary", type_):
            return "bytes"
        elif type_ == "geometry":
            return "geometry"
        elif type_ == "":
            return "unknown"
        else:
            raise ValueError(f"Type {type_} not supported yet")

    def replace_vars(self, sql, db):
        if "curdate" in sql.lower():
            sql = date.today().strftime("%Y-%m-%d")
        elif "current_date" in sql.lower():
            sql = date.today().strftime("%Y-%m-%d")
        elif "current_timestamp" in sql.lower():
            sql = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        elif "current_user" in sql.lower():
            sql = db.cnxn.user

        return sql

    def databases(self):
        if self.platform == 'sqlite':
            # For selecting from `urdr.database_`
            return """
            with recursive cte_access (code, parent) as (
                select a1.code, a1.parent
                from access a1
                join user_access ua on ua.access_code = a1.code
                where ua.user_id = :uid
                union all
                select a2.code, a2.parent
                from access a2
                join cte_access cte on cte.code = a2.parent
            )
            select name, description
            from database_ db
            left join database_access dba on dba.database_name = db.name
            where read_access is null
               or read_access in (select code from cte_access)
            """

        elif self.platform == 'postgresql':
            return """
            select d.datname as db_name,
                   shobj_description(d.oid, 'pg_database') as db_comment
            from pg_database d
            where datistemplate is false and datname != 'postgres'
                  and cast(:cat as varchar) is null or d.datname = :cat
            """
        elif self.platform == 'oracle':
            # Oracle doesn't support comments on schemas
            return """
            SELECT DISTINCT owner as db_name, NULL as db_comment
            FROM ALL_OBJECTS
            WHERE OBJECT_TYPE = 'TABLE'
            order by owner
            """
        elif self.platform == 'mysql':
            return """
            select schema_name as db_name, NULL as db_comment
            from information_schema.schemata
            where :schema is null or schema_name = :schema
            """
        elif self.platform == 'mariadb':
            return """
            select schema_name as db_name, schema_comment as db_comment
            from information_schema.schemata
            where :schema is null or schema_name = :schema
            """
        elif self.platform == 'mssql':
            return """
            select name as db_name, NULL as db_comment
            from sys.Databases
            WHERE name NOT IN ('master', 'tempdb', 'model', 'msdb')
                  and HAS_DBACCESS(name) = 1;
            """

    def schemata(self):
        if self.platform == 'postgresql':
            return """
            select schema_name
            from information_schema.schemata
            where schema_name != 'information_schema'
              and schema_name not like 'pg_%';
            """

    def indexes(self):
        if self.platform == 'sqlite':
            return """
            select c.name as index_name, m.name as table_name,
                   case when c."unique" = 1 then 0 else 1 end as non_unique,
                   i.name as column_name
            from sqlite_master m
            join pragma_index_list(m.name) c
            join pragma_index_info(c.name) i
            where c.origin = 'c'
            order by c.name, i.seqno;
            """
        if self.platform == 'oracle':
            return """
            select i.index_name as "index_name",
            case uniqueness when 'NONUNIQUE' then 1 else 0 end as "non_unique",
            column_name as "column_name", column_position as "column_position",
            i.table_name as "table_name"
            from all_indexes i
            join all_ind_columns col on col.index_name = i.index_name
            where i.table_owner = :schema
                  and i.table_name = nvl(:table, i.table_name) 
                  and column_name not like '%$'
            order by column_position
            """
        elif self.platform == 'duckdb':
            return """
            select index_name, table_name, expressions as column_names,
                   case when is_unique = 1 then 0 else 1 end as non_unique,
            from duckdb_indexes()
            where schema_name = :schema
                  and table_name = coalesce(:table, table_name)
            """
        elif self.platform in ('mysql', 'mariadb'):
            return """
            select index_name, column_name, non_unique, table_name
            from information_schema.statistics
            where table_schema = :schema
                  and table_name = coalesce(:table, table_name)
            order by index_name, seq_in_index;
            """
        elif self.platform == 'mssql':
            return """
            SELECT 
                OBJECT_NAME(ic.object_id) AS table_name,
                i.name AS index_name,
                case when i.is_unique = 1 then 0 else 1 end as non_unique,
                c.name AS column_name,
                ic.key_ordinal,
                ic.is_included_column
            FROM 
                sys.index_columns ic
            JOIN 
                sys.indexes i ON ic.object_id = i.object_id AND ic.index_id = i.index_id
            JOIN 
                sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id
            WHERE 
                OBJECT_SCHEMA_NAME(i.object_id) = :schema
                and OBJECT_NAME(ic.object_id) = coalesce(:table, OBJECT_NAME(ic.object_id))
            ORDER BY 
                table_name, index_name, ic.key_ordinal;
            """
        else:
            return None

    def pkeys(self):
        if self.platform == 'sqlite':
            return """
            select concat(m.name, '_pkey') as pk_name, m.name as table_name,
                   c.name as column_name 
            from sqlite_master m
            join pragma_table_info(m.name) c
            where m.type = 'table'
                  and c.pk = 1
                  and m.name = coalesce(:table, m.name)
            """
        if self.platform == 'oracle':
            return """
            SELECT cols.table_name, cols.column_name, cols.position as key_seq,
                   cons.status, cons.owner, cons.constraint_name as pk_name
            FROM all_constraints cons, all_cons_columns cols
            WHERE cons.constraint_type = 'P'
            AND cons.constraint_name = cols.constraint_name
            AND cons.owner = cols.owner
            AND cons.owner = :schema
            AND cols.table_name = nvl(:table, cols.table_name)
            ORDER BY cols.table_name, cols.position;
            """
        elif self.platform in ('mysql', 'mariadb'):
            return """
            select s.index_name as pk_name, s.table_name, s.column_name,
                   c.data_type
            from information_schema.statistics s
            join information_schema.columns c
              on c.table_schema = s.table_schema and
                 c.table_name = s.table_name and
                 c.column_name = s.column_name
            where s.table_schema = :schema and s.index_name = 'primary'
              and s.table_name = coalesce(:table, s.table_name)
            order by s.table_name, seq_in_index;
            """
        elif self.platform == 'mssql':
            return """
            select 
                pk.[name] as pk_name,
                ic.index_column_id as column_id,
                col.[name] as column_name, 
                tab.[name] as table_name
            from sys.tables tab
                inner join sys.indexes pk
                    on tab.object_id = pk.object_id 
                    and pk.is_primary_key = 1
                inner join sys.index_columns ic
                    on ic.object_id = pk.object_id
                    and ic.index_id = pk.index_id
                inner join sys.columns col
                    on pk.object_id = col.object_id
                    and col.column_id = ic.column_id
            where schema_name(tab.schema_id) = :schema
              and tab.[name] = coalesce(:table, tab.[name])
            order by
                pk.[name],
                ic.index_column_id
            """
        else:
            return None

    def pkey(self, table_name=None):
        if self.platform == 'sqlite':
            return f"""
            SELECT name as column_name, NULL as pk_name
            FROM pragma_table_info('{table_name}')
            WHERE pk != 0 order by pk
            """
        elif self.platform in ('mysql', 'mariadb'):
            return f"show index from {table_name} where Key_name = 'PRIMARY'"

    def fkeys(self):
        if self.platform == 'sqlite':
            return """
            select concat(m.name, '_fk_', p.id) as fk_name,
                   m.name as fktable_name,
                   p."from" as fkcolumn_name,
                   p."table" as pktable_name,
                   p."to" as pkcolumn_name,
                   p.on_update as update_rule,
                   p.on_delete as delete_rule
            from sqlite_master m
            join pragma_foreign_key_list(m.name) p on m.name != p."table"
            where m.type = 'table'
                  and m.name = coalesce(:table, m.name)
            order by m.name
            """
        if self.platform in ('mysql', 'mariadb'):
            return """
            SELECT kcu.constraint_name as fk_name,
                   kcu.table_name as fktable_name,
                   kcu.column_name as fkcolumn_name,
                   kcu.referenced_table_schema as pktable_schem,
                   kcu.referenced_table_name as pktable_name,
                   kcu.referenced_column_name as pkcolumn_name,
                   rc.update_rule, rc.delete_rule
            FROM INFORMATION_SCHEMA.key_column_usage kcu
            JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc
                 on kcu.constraint_name = rc.constraint_name
            WHERE kcu.referenced_table_schema = :schema
                  and kcu.table_name = coalesce(:table, kcu.table_name)
            AND kcu.referenced_table_name IS NOT NULL
            ORDER BY kcu.table_name, kcu.ordinal_position
            """
        elif self.platform == 'oracle':
            return """
            SELECT  a.column_name as fkcolumn_name, a.position,
                    a.constraint_name as fk_name, a.table_name as fktable_name,
                    c.owner, c.delete_rule,
                    -- referenced pk
                    c.r_owner as pktable_schem,
                    c_pk.table_name as pktable_name,
                    c_pk.constraint_name r_pk,
                    ra.column_name pkcolumn_name
            FROM all_cons_columns a
                JOIN all_constraints c
                ON a.owner = c.owner
                AND a.constraint_name = c.constraint_name
                JOIN all_constraints c_pk
                ON c.r_owner = c_pk.owner
                AND c.r_constraint_name = c_pk.constraint_name
                JOIN all_cons_columns ra
                ON ra.owner = c.owner
                AND ra.constraint_name = c_pk.constraint_name
                AND ra.position = a.position
            WHERE c.constraint_type = 'R'
                  AND a.owner = :schema
                  AND a.table_name = nvl(:table, a.table_name)
            ORDER BY a.position
            """
        elif self.platform == 'postgresql':
            return """
            select
                con.relname as fktable_name,
                att2.attname as fkcolumn_name,
                ns.nspname as pktable_schem,
                cl.relname as pktable_name,
                att.attname as pkcolumn_name,
                conname as fk_name,
                CASE con.confdeltype
                    WHEN 'a' THEN 'NO ACTION'
                    WHEN 'r' THEN 'RESTRICT'
                    WHEN 'c' THEN 'CASCADE'
                    WHEN 'n' THEN 'SET NULL'
                    WHEN 'd' THEN 'SET DEFAULT'
                    ELSE 'UNKNOWN'
                END AS delete_rule,
                CASE con.confupdtype
                    WHEN 'a' THEN 'NO ACTION'
                    WHEN 'r' THEN 'RESTRICT'
                    WHEN 'c' THEN 'CASCADE'
                    WHEN 'n' THEN 'SET NULL'
                    WHEN 'd' THEN 'SET DEFAULT'
                    ELSE 'UNKNOWN'
                END AS update_rule
            from
            (select
                    unnest(con1.conkey) as "parent",
                    unnest(con1.confkey) as "child",
                    cl.relname,
                    con1.confrelid,
                    con1.conrelid,
                    con1.conname,
                    con1.confdeltype,
                    con1.confupdtype
                from
                    pg_class cl
                    join pg_namespace ns on cl.relnamespace = ns.oid
                    join pg_constraint con1 on con1.conrelid = cl.oid
                where
                    con1.contype = 'f'
                    and ns.nspname = :schema
                    and cl.relname = coalesce(:table, cl.relname)

            ) con
            join pg_attribute att on
                att.attrelid = con.confrelid and att.attnum = con.child
            join pg_class cl on
                cl.oid = con.confrelid
            join pg_attribute att2 on
                att2.attrelid = con.conrelid and att2.attnum = con.parent
            join pg_namespace ns on
                ns.oid=cl.relnamespace
            """
        elif self.platform == 'mssql':
            return """
            SELECT C.TABLE_CATALOG as fktable_cat,
                   C.TABLE_SCHEMA as fktable_schem,
                   C.TABLE_NAME as fktable_name,
                   KCU.COLUMN_NAME as fkcolumn_name,
                   C2.TABLE_CATALOG as pktable_cat,
                   C2.TABLE_SCHEMA as pktable_schem,
                   C2.TABLE_NAME as pktable_name,
                   KCU2.COLUMN_NAME as pkcolumn_name,
                   RC.UPDATE_RULE as update_rule,
                   RC.DELETE_RULE as delete_rule,
                   C.CONSTRAINT_NAME as fk_name,
                   C2.CONSTRAINT_NAME [PK_NAME],
                   CAST(7 AS SMALLINT) [DEFERRABILITY]
            FROM   INFORMATION_SCHEMA.TABLE_CONSTRAINTS C
                   INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU
                     ON C.CONSTRAINT_SCHEMA = KCU.CONSTRAINT_SCHEMA
                        AND C.CONSTRAINT_NAME = KCU.CONSTRAINT_NAME
                   INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS RC
                     ON C.CONSTRAINT_SCHEMA = RC.CONSTRAINT_SCHEMA
                        AND C.CONSTRAINT_NAME = RC.CONSTRAINT_NAME
                   INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS C2
                     ON RC.UNIQUE_CONSTRAINT_SCHEMA = C2.CONSTRAINT_SCHEMA
                        AND RC.UNIQUE_CONSTRAINT_NAME = C2.CONSTRAINT_NAME
                   INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU2
                     ON C2.CONSTRAINT_SCHEMA = KCU2.CONSTRAINT_SCHEMA
                        AND C2.CONSTRAINT_NAME = KCU2.CONSTRAINT_NAME
                        AND KCU.ORDINAL_POSITION = KCU2.ORDINAL_POSITION
            WHERE  C.CONSTRAINT_TYPE = 'FOREIGN KEY'
                   AND C.TABLE_SCHEMA = :schema
                   AND C.TABLE_NAME = coalesce(:table, C.TABLE_NAME) 
            """
        else:
            return None

    def columns(self, tbl_name=None):
        if self.platform == 'sqlite':
            return"""
            select m.name as table_name,
                   c.name as column_name,
                   c.type as type_name,
                   c.dflt_value as column_def,
                   null as column_size,
                   case c."notnull" when 0 then 1 else 0 end as nullable
            from sqlite_master m
            join pragma_table_info(m.name) c
            where m.type = 'table'
                  and m.name = coalesce(:table, m.name)
            order by m.name
            """
        elif self.platform == 'duckdb':
            return """
            select table_name, column_name, is_nullable as nullable,
                   column_default as column_def, data_type as type_name
            from duckdb_columns
            where schema_name = 'main'
                  and table_name = coalesce(:table, table_name)
            """
        elif self.platform == 'oracle':
            return """
            select  table_name as "table_name",
                    column_name as "column_name",
                    data_type as "type_name", data_length as "column_size",
                    case nullable when 'Y' then 1 else 0 end as "nullable"
            from all_tab_columns
            where owner = :schema
                  and table_name = nvl(:table, table_name)
            order by table_name, column_id
            """
        elif self.platform == 'mssql':
            return """
            select table_name, column_name, data_type as type_name,
                   case when numeric_precision is not null then
                       numeric_precision else character_maximum_length
                   end as column_size,
                   case is_nullable when 'YES' then 1 else 0 end as nullable,
                   numeric_scale as decimal_digits,
                   column_default as column_def
            from   information_schema.columns
            where  table_schema = :schema and table_name = coalesce(:table, table_name) 
            """
        elif tbl_name and self.platform == 'sqlite':
            return f"""
            select name, type, case when "notnull" = 1 then 0 else 1 end as nullable,
                   dflt_value as "default" from pragma_table_info('{tbl_name}')
            """
        elif tbl_name and self.platform == 'duckdb':
            return f"""
            select table_name, column_name as name, is_nullable as nullable,
                   column_default as "default", data_type as type
            from duckdb_columns
            where schema_name = 'main' and table_name = '{tbl_name}'
            """
        else:
            return None

    def rowcount(self):
        if self.platform == 'mssql':
            return """
            SELECT t.name as table_name, p.rows as count_rows
            FROM sys.partitions AS p
            INNER JOIN sys.tables AS t
            ON p.[object_id] = t.[object_id]
            INNER JOIN sys.schemas AS s
            ON s.[schema_id] = t.[schema_id]
            WHERE s.name = :schema
            AND p.index_id IN (0,1);
            """
        else:
            return None

    def rows(self, tbl, cond):

        fkey = tbl.get_parent_fk()
        if fkey and self.platform in ['mysql', 'postgresql', 'sqlite']:
            cols = tbl.db.refl.get_columns(self.name, self.db.schema)
            colnames = []
            for col in cols:
                colnames.append(col['name'])

            select = ', '.join(colnames)
            fkey_cc = fkey['constrained_columns'][0]
            fkey_rc = fkey['referred_columns'][0]
            join = '\n'.join(tbl.joins.values())
            cond = cond or '1 = 1'
              
            sql = f"""
            with recursive tbl_data as (
                select {tbl.name}.*, 1 as level
                from {tbl.name}
                {join}
                where {tbl.name}.{fkey_cc} is null and {cond}

                union all

                select this.*, prior.level + 1
                from tbl_data prior
                inner join {tbl.name} this
                   on this.{fkey_cc} = prior.{fkey_rc}
            )
            select {select}
            from tbl_data
            order by level
            """
        else:
            sql = f"select {tbl.name}.* from {tbl.name}"
            if cond:
                sql += '\n' + '\n'.join(tbl.joins.values())
                sql += ' where ' + cond

        return sql

    def insert_rec(self, tbl, rec):
        insert = ''
        if self.platform == 'oracle':
            insert += 'select '
        else:
            insert += '('
        for colname, val in rec.items():
            col = tbl.fields[colname]
            if (tbl.name == 'meta_data' and colname == 'cache'):
                val = ''
            if type(val) is str:
                val = val.replace('\\n', '\n').replace('\\t', '\t')
                val = "'" + val.strip().replace("'", "''") + "'"
            elif isinstance(val, date):
                val = "'" + str(val) + "'"
            elif (col.datatype == 'bool' and self.platform == 'oracle'):
                if val is False:
                    val = 0
                elif val is True:
                    val = 1
            elif val is None:
                val = 'null'
            if self.platform == 'oracle': 
                insert += str(val).replace('\n', "' || CHR(10) || '") + ','
            else:
                insert += str(val) + ','
        if self.platform == 'oracle':
            insert = insert[:-1] + ' from dual'
        else:
            insert = insert[:-1] + ')'

        return insert

    def privilege(self):
        if self.platform == 'postgresql':
            sql = "select pg_catalog.has_schema_privilege"
            sql += """(current_user, nspname, 'CREATE') "create"
            from pg_catalog.pg_namespace
            where nspname = ?
            """
            return sql
        else:
            return None

    def user_tables(self):
        if self.platform == 'sqlite':
            return """
            SELECT name as table_name, type as table_type, null as remarks
            FROM   sqlite_master
            WHERE  type IN ('table', 'view')
                   AND name = coalesce(:table, name)
            """
        elif self.platform == 'oracle':
            return """
            SELECT object_name as table_name, object_type as table_type,
                   null as remarks
            FROM   all_objects
            WHERE  object_type in ('TABLE', 'VIEW')
                   AND owner = :schema;
                   AND object_name = coalesce(:table, object_name)
            """
        else:
            return """
            SELECT table_name, table_type, table_comment as remarks
            FROM   information_schema.tables
            WHERE  table_schema = :schema;
                   AND table_name =  coalesce(:table, table_name)
            """

    def table_privileges(self):
        if self.platform == 'postgresql':
            return """
            select privilege_type
            from information_schema.table_privileges
            where grantee = ?
            and table_name = ?;
            """
        else:
            return None

    def view_names(self):
        if self.platform == 'sqlite':
            return """
            SELECT name as table_name, type as table_type 
            FROM sqlite_schema
            WHERE type = 'view';
            """

    def view_definition(self):
        if self.platform in ('mysql', 'mariadb'):
            return """
            SELECT  VIEW_DEFINITION
            FROM    INFORMATION_SCHEMA.VIEWS
            WHERE   TABLE_SCHEMA    = :schema
            AND     TABLE_NAME      = :table;
            """
        elif self.platform == 'oracle':
            return """
            SELECT text FROM user_views where view_name = :table;
            """
        elif self.platform == 'sqlite':
            return """
            select sql from sqlite_master where name = :table
            """
        else:
            return None

    def functionlines(self):
        if self.platform == 'oracle':
            return """
            SELECT name as "name", text as "text"
            FROM   all_source
            WHERE  owner = :owner and type = 'FUNCTION'
            ORDER BY name, line
            """
        else:
            return None

    def procedurelines(self):
        if self.platform == 'oracle':
            return """
            SELECT name as "name", text as "text"
            FROM   all_source
            WHERE  owner = :owner and type = 'PROCEDURE'
            ORDER BY name, line
            """
        else:
            return None

    def quote(self, object_name):
        if self.platform in ('mssql'):
            return '"' + object_name + '"'
        else:
            return object_name
