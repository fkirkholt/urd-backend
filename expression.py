import re
from datetime import date, datetime


class Expression:
    def __init__(self, platform):
        self.platform = platform

    def autoincrement(self):
        if (self.platform == 'mysql'):
            return "AUTO_INCREMENT"
        elif (self.platform == 'oracle'):
            return "GENERATED BY DEFAULT ON NULL AS IDENTITY"
        elif (self.platform == 'postgresql'):
            return "SERIAL"
        elif (self.platform == 'sqlite'):
            return "AUTOINCREMENT"

    def get_mysql_type(self, type_, size):
        if type_ == "str":
            return "varchar(" + str(size) + ")" if size else "longtext"
        elif type_ == "int":
            return "int(" + str(size) + ")"
        elif type_ == "Decimal":
            return "decimal(" + str(size) + ") "
        elif type_ == "float":
            return "float(" + str(size) + ")"
        elif type_ == "date":
            return "date"
        elif type_ == "bool":
            return "tinyint(1)"
        elif type_ == "bytes":
            return "blob"
        else:
            raise ValueError(f"Type {type_} not supported yet")

    def get_sqlserver_type(self, type_, size):
        if type_ == 'str':
            return ('varchar(' + str(size) + ')'
                    if (size and size > 0) else 'varchar(max)')
        elif type_ == 'int':
            return 'int'
        elif type_ == 'Decimal':
            return 'decimal(' + str(size) + ')'
        elif type_ == 'float':
            return 'float(' + str(size) + ')'
        elif type_ == 'date':
            return 'date'
        elif type_ == 'bool':
            return 'bit'
        elif type_ == 'bytes':
            return 'varbinary(max)'
        else:
            raise ValueError(f"Type {type_} not supported yet")

    def get_sqlite_type(self, type_, size):
        if type_ in ["str"]:
            return "varchar(" + str(size) + ")" if size else "text"
        elif type_ == "date":
            return "date"
        elif type_ in ["int", "bool"]:
            return "integer"
        elif type_ == "Decimal":
            return "decimal"
        elif type_ == "float":
            return "real"
        elif type_ == "bytes":
            return "blob"
        elif type_ == "json":
            return "json"
        else:
            raise ValueError(f"Type {type_} not supported yet")

    def get_postgres_type(self, type_, size):
        if type_ == "str" and size:
            return "varchar(" + str(size) + ")"
        elif type_ == "str":
            return "text"
        elif (type_ == "int" and size and size > 11):
            return "bigint"
        elif type_ == "int":
            return "integer"
        elif type_ == "Decimal":
            return "decimal(" + str(size) + ")"
        elif type_ == "float":
            return "float(" + str(size) + ")"
        elif type_ == "date":
            return "date"
        elif type_ == "bool":
            return "boolean"
        elif type_ == "bytes":
            return "bytea"
        elif type_ == "json":
            return "json"

    def get_oracle_type(self, type_, size):
        if (type_ == "str" and (not size or size > 4000)):
            return "clob"
        elif type_ == "str":
            return "varchar(" + str(size) + ")"
        elif (type_ == "int" and size > 11):
            return "number(" + str(size) + ", 0)"
        elif type_ == "int":
            return "integer"
        elif type_ == "float":
            return "float(" + str(size) + ")"
        elif type_ == "date":
            return "date"
        elif type_ == "bool":
            return "number(1)"
        elif type_ == "bytes":
            return "blob"

    def to_native_type(self, type_, size=None):
        if self.platform in ['mysql', 'mariadb']:
            return self.get_mysql_type(type_, size)
        elif self.platform == 'mssql':
            return self.get_sqlserver_type(type_, size)
        elif self.platform == "sqlite":
            return self.get_sqlite_type(type_, size)
        elif self.platform == 'postgresql':
            return self.get_postgres_type(type_, size)
        elif self.platform == 'oracle':
            return self.get_oracle_type(type_, size)
        else:
            raise ValueError(f"Type conversion for {self.platform} not "
                             "implemented")

    def replace_vars(self, sql, db):
        if "curdate" in sql.lower():
            sql = date.today().strftime("%Y-%m-%d")
        elif "current_date" in sql.lower():
            sql = date.today().strftime("%Y-%m-%d")
        elif "current_timestamp" in sql.lower():
            sql = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        elif "current_user" in sql.lower():
            sql = db.user

        return sql

    def databases(self, db_name=None):
        if self.platform == 'postgresql':
            return """
            select d.datname as db_name,
                   shobj_description(d.oid, 'pg_database') as db_comment
            from pg_database d
            where datistemplate is false and datname != 'postgres'
                  and :db_name is null or d.datname = :db_name
            """
        elif self.platform == 'oracle':
            return """
            SELECT DISTINCT OWNER as db_name, NULL as db_comment
              FROM ALL_OBJECTS
             WHERE OBJECT_TYPE = 'TABLE'
            order by owner;
            """
        elif self.platform == 'mysql':
            return """
            select schema_name as db_name, NULL as db_comment
            from information_schema.schemata
            """
        elif self.platform == 'mariadb':
            return """
            select schema_name as db_name, schema_comment as db_comment
            from information_schema.schemata
            where :db_name is null or schema_name = :db_name
            """
        elif self.platform == 'mssql':
            return """
            select name as db_name, NULL as db_comment
            from sys.Databases
            WHERE name NOT IN ('master', 'tempdb', 'model', 'msdb')
                  and HAS_DBACCESS(name) = 1;
            """

    def schema_privileges(self):
        if self.platform == 'postgresql':
            return """
            select pg_catalog.has_schema_privilege(current_user, nspname, 'CREATE') "create",
                   pg_catalog.has_schema_privilege(current_user, nspname, 'USAGE') "usage"
            from pg_catalog.pg_namespace
            where nspname = :schema
            """
            return sql
        elif self.platform in ['mysql', 'mariadb']:
            # https://bugs.mysql.com/bug.php?id=75423
            return """
            select privilege_type
            from information_schema.schema_privileges
            where grantee = CONCAT('\\'',REPLACE(CURRENT_USER(),'@','\\'@\\''),'\\'')
            and table_schema = :schema
            """
        else:
            return None

    def table_privileges(self):
        if self.platform == 'postgresql':
            return """
            select privilege_type
            from information_schema.table_privileges
            where grantee = current_user
            and table_schema = :schema
            and table_name = :table;
            """
        elif self.platform in ['mysql', 'mariadb']:
            return """
            select privilege_type
            from information_schema.table_privileges
            where grantee = CONCAT('\\'',REPLACE(CURRENT_USER(),'@','\\'@\\''),'\\'')
            and table_schema = :schema
            and table_name = :table
            """
        else:
            return None

    def view_definition(self):
        if self.platform in ['mysql', 'mariadb']:
            return """
            SELECT  VIEW_DEFINITION
            FROM    INFORMATION_SCHEMA.VIEWS
            WHERE   TABLE_SCHEMA    = :schema
            AND     TABLE_NAME      = :table;
            """
        else:
            return None

    def table_comments(self):
        if self.platform in ['mysql', 'mariadb']:
            return """
            select table_name, table_comment
            from   information_schema.tables
            where table_schema = :schema
            """
